{-# LANGUAGE RecordWildCards #-}

import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
import FourmoluConfig.ConfigData
import FourmoluConfig.GenerateUtils
import Text.Printf (printf)

main :: IO ()
main = do
  writeFile "../src/Ormolu/Config/Gen.hs" configGenHs

configGenHs :: String
configGenHs =
  unlines
    [ "{- FOURMOLU_DISABLE -}",
      "{- ***** DO NOT EDIT: This module is autogenerated ***** -}",
      "",
      "{-# LANGUAGE DeriveGeneric #-}",
      "{-# LANGUAGE LambdaCase #-}",
      "{-# LANGUAGE OverloadedStrings #-}",
      "{-# LANGUAGE RankNTypes #-}",
      "",
      "module Ormolu.Config.Gen",
      "  ( PrinterOpts (..)",
      unlines_ $ map (printf "  , %s (..)" . fieldTypeName) allFieldTypes,
      "  , emptyPrinterOpts",
      "  , defaultPrinterOpts",
      "  , ormoluPrinterOpts",
      "  , defaultPrinterOptsYaml",
      "  , fillMissingPrinterOpts",
      "  , parseFourmoluOptsCLI",
      "  , parsePrinterOptsJSON",
      "  , parseFourmoluConfigType",
      "  )",
      "where",
      "",
      "import qualified Data.Aeson as Aeson",
      "import qualified Data.Aeson.Types as Aeson",
      "import Data.Functor.Identity (Identity)",
      "import Data.Scientific (floatingOrInteger)",
      "import qualified Data.Text as Text",
      "import GHC.Generics (Generic)",
      "import Network.URI (URI)",
      "import qualified Network.URI as URI",
      "import Text.Read (readEither, readMaybe)",
      "",
      "-- | Options controlling formatting output.",
      "data PrinterOpts f =",
      indent . mkPrinterOpts $ \(fieldName, _, Option {..}) ->
        unlines_
          [ printf "-- | %s" description,
            printf "  %s :: f %s" fieldName type_
          ],
      "  deriving (Generic)",
      "",
      "emptyPrinterOpts :: PrinterOpts Maybe",
      "emptyPrinterOpts =",
      indent . mkPrinterOpts $ \(fieldName, _, _) ->
        fieldName <> " = Nothing",
      "",
      mkPresetOpts "defaultPrinterOpts" presetFourmolu,
      "",
      mkPresetOpts "ormoluPrinterOpts" presetOrmolu,
      "",
      "-- | Fill the field values that are 'Nothing' in the first argument",
      "-- with the values of the corresponding fields of the second argument.",
      "fillMissingPrinterOpts ::",
      "  forall f.",
      "  Applicative f =>",
      "  PrinterOpts Maybe ->",
      "  PrinterOpts f ->",
      "  PrinterOpts f",
      "fillMissingPrinterOpts p1 p2 =",
      indent . mkPrinterOpts $ \(fieldName, _, _) ->
        printf "%s = maybe (%s p2) pure (%s p1)" fieldName fieldName fieldName,
      "",
      "parseFourmoluOptsCLI ::",
      "  Applicative f =>",
      "  (PrinterOpts Maybe -> Maybe ConfigPreset -> a) ->",
      "  (forall opt. FourmoluConfigType opt => String -> String -> String -> f (Maybe opt)) ->",
      "  f a",
      "parseFourmoluOptsCLI toResult mkOption =",
      "  toResult",
      "    <$> parsePrinterOptsCLI",
      "    <*> parsePresetOptCLI",
      "  where",
      "    parsePrinterOptsCLI =",
      "      pure PrinterOpts",
      indent' 4 . unlines_ $
        [ unlines_
            [ "<*> mkOption",
              indent . unlines_ $
                [ quote name,
                  quote (getCLIHelp option),
                  quote (getCLIPlaceholder option)
                ]
            ]
          | option@Option {name, info = PrinterOptsOption {}} <- allOptions
        ],
      "    parsePresetOptCLI =",
      "      mkOption",
      indent' 4 . unlines_ $
        let option = getOption "preset"
         in [ quote (name option),
              quote (getCLIHelp option),
              quote (getCLIPlaceholder option)
            ],
      "",
      "parsePrinterOptsJSON ::",
      "  Applicative f =>",
      "  (forall a. FourmoluConfigType a => String -> f (Maybe a)) ->",
      "  f (PrinterOpts Maybe)",
      "parsePrinterOptsJSON f =",
      "  pure PrinterOpts",
      indent' 2 . unlines_ $
        [ "<*> f " <> quote name
          | Option {name, info = PrinterOptsOption {}} <- allOptions
        ],
      "",
      "{---------- PrinterOpts field types ----------}",
      "",
      "class Aeson.FromJSON a => FourmoluConfigType a where",
      "  parseFourmoluConfigType :: String -> Either String a",
      "",
      "instance FourmoluConfigType Int where",
      "  parseFourmoluConfigType = readEither",
      "",
      "instance FourmoluConfigType Bool where",
      "  parseFourmoluConfigType s =",
      "    case s of",
      "      \"false\" -> Right False",
      "      \"true\" -> Right True",
      "      _ ->",
      "        Left . unlines $",
      "          [ \"unknown value: \" <> show s,",
      "            \"Valid values are: \\\"false\\\" or \\\"true\\\"\"",
      "          ]",
      "",
      unlines_
        [ unlines_ $
            case fieldType of
              FieldTypeEnum {..} ->
                [ mkDataType fieldTypeName (map fst enumOptions),
                  "  deriving (Eq, Show, Enum, Bounded)",
                  ""
                ]
              FieldTypeADT {..} ->
                [ mkDataType fieldTypeName adtConstructors,
                  "  deriving (Eq, Show)",
                  ""
                ]
          | fieldType <- allFieldTypes
        ],
      unlines_
        [ unlines_ $
            case fieldType of
              FieldTypeADT {adtParseJSON = Just customParse} ->
                [ printf "instance Aeson.FromJSON %s where" name,
                  printf "  parseJSON =",
                  indent' 2 customParse,
                  printf ""
                ]
              _ ->
                [ printf "instance Aeson.FromJSON %s where" name,
                  printf "  parseJSON =",
                  printf "    Aeson.withText \"%s\" $ \\s ->" name,
                  printf "      either Aeson.parseFail pure $",
                  printf "        parseFourmoluConfigType (Text.unpack s)",
                  printf ""
                ]
          | fieldType <- allFieldTypes,
            let name =
                  case fieldType of
                    FieldTypeEnum {..} -> fieldTypeName
                    FieldTypeADT {..} -> fieldTypeName
        ],
      unlines_
        [ unlines_ $
            case fieldType of
              FieldTypeEnum {..} ->
                [ printf "instance FourmoluConfigType %s where" fieldTypeName,
                  printf "  parseFourmoluConfigType s =",
                  printf "    case s of",
                  unlines_
                    [ printf "      \"%s\" -> Right %s" val con
                      | (con, val) <- enumOptions
                    ],
                  printf "      _ ->",
                  printf "        Left . unlines $",
                  printf "          [ \"unknown value: \" <> show s",
                  printf "          , \"Valid values are: %s\"" (renderEnumOptions enumOptions),
                  printf "          ]",
                  printf ""
                ]
              FieldTypeADT {..} ->
                [ printf "instance FourmoluConfigType %s where" fieldTypeName,
                  printf "  parseFourmoluConfigType =",
                  indent' 2 adtParseFourmoluConfigType,
                  printf ""
                ]
          | fieldType <- allFieldTypes
        ],
      "defaultPrinterOptsYaml :: String",
      "defaultPrinterOptsYaml =",
      "  unlines",
      indent' 2 (renderMultiLineStringList fourmoluYamlFourmoluStyle)
    ]
  where
    mkPrinterOpts :: ((String, PresetOptions, Option) -> String) -> String
    mkPrinterOpts f =
      let fieldOptions =
            [ (fieldName, presets, o)
              | o@Option {info = PrinterOptsOption {..}} <- allOptions
            ]
       in unlines_
            [ "PrinterOpts",
              indent . unlines_ $
                [ printf "%c %s" delim (f option)
                  | (isFirst, option) <- withFirst fieldOptions,
                    let delim = if isFirst then '{' else ','
                ],
              "  }"
            ]

    mkDataType name cons =
      unlines_ $
        "data " <> name
          : [ printf "  %c %s" delim con
              | (isFirst, con) <- withFirst cons,
                let delim = if isFirst then '=' else '|'
            ]

    mkPresetOpts name getPreset =
      unlines_
        [ name <> " :: PrinterOpts Identity",
          name <> " =",
          indent . mkPrinterOpts $ \(fieldName, presets, _) ->
            fieldName <> " = pure " <> renderHs (getPreset presets)
        ]

    renderEnumOptions enumOptions =
      renderList [printf "\\\"%s\\\"" opt | (_, opt) <- enumOptions]

    renderMultiLineStringList =
      unlines . (++ ["]"]) . zipWith (\c str -> c : ' ' : show str) ('[' : repeat ',') . lines

    getCLIHelp option@Option {..} =
      let help = fromMaybe description (cliHelp cliOverrides)
          choicesText =
            case type_ `Map.lookup` fieldTypesMap of
              Just FieldTypeEnum {enumOptions} ->
                printf " (choices: %s)" (renderEnumOptions enumOptions)
              _ -> ""
          defaultText =
            printf " (default: %s)" $
              fromMaybe (defaultYaml option) (cliDefault cliOverrides)
       in concat [help, choicesText, defaultText]

    getCLIPlaceholder Option {..}
      | Just placeholder <- cliPlaceholder cliOverrides = placeholder
      | "Bool" <- type_ = "BOOL"
      | "Int" <- type_ = "INT"
      | otherwise = "OPTION"

-- | Default fourmolu config that can be printed via `fourmolu --print-defaults`
fourmoluYamlFourmoluStyle :: String
fourmoluYamlFourmoluStyle = unlines_ config
  where
    config =
      [ printf "# %s\n%s: %s\n" (getComment opt) name (defaultYaml opt)
        | opt@Option {..} <- allOptions
      ]

    getComment Option {..} =
      let help = fromMaybe description (cliHelp cliOverrides)
          choicesText =
            case type_ `Map.lookup` fieldTypesMap of
              Just FieldTypeEnum {enumOptions} ->
                printf " (choices: %s)" (renderList $ map snd enumOptions)
              _ -> ""
       in concat [help, choicesText]
